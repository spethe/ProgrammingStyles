Review: Concepts & Experiments in computational reflection

	This paper deals with the concept of reflection in programming languages. It observes the ways in which reflection is done in procedural and logic languages. However, the main objective of the paper is to introduce a reflective architecture in an object-oriented language.
	It starts with the concept of ‘reflection’.  A computational system is said to be ‘reflective’ if it has corresponding structures representing its internal architecture and working. This self-representation helps the system to answer questions about itself. Also, for a system related to a language must be causally connected to its domain i.e. an internal change leads to a corresponding effect.
This also implies that an accurate internal representation facilitates modifications to itself by monitoring its own computation. Talking about practical applications of reflection, they obviously have application in monitoring the performance statistics of the computation system. It also comes in handy in debugging and in situations where self- modification or activation or optimization is necessary for the system.
	Then comes the study of the existing architectures of programming languages that support reflection. The ‘reflective’ architectures recognize reflection as a fundamental concept and thus provide tools for handling reflection computation. Most of the existing reflective architectures attempt to support a distinction between reflective level of computation and object level of computation. Typically, reflective functions are local/temporary functions running at the level of the interpreter that manipulate the data pertaining to the code, environment, in short, the metadata. Many procedural languages use the meta circular interpreter to support the reflective architecture.
	Then the history of development of reflective architecture in object oriented languages is surveyed. One of the important tricks was the introduction of meta classes. This helps to keep the behavior of the entity and the internal representation of the class distinct. The author introduces the 3KRS architecture supporting reflection. This architecture makes use of meta objects for every object. This one-one correspondence gives the architecture the much needed distinction between the reflection level computation and the object level computation. This makes use of abstractions and encapsulation in object oriented programming to achieve reflection. 
	Reflection in OO languages is a very useful tool in certain situations where achieving the goal through object-level computation is heavy and cumbersome. Having said that, reflection must only be used wherever necessary.
