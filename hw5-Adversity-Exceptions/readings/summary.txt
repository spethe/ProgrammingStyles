    In this paper, the author Luca Cardelli does an exhaustive analysis of parts and parcels related to types in programming languages. First and foremost, a type system is in existence to prevent execution errors. Execution errors occur during running of the program and may occur due to illegal memory reference or unsupported operations on a particular data. Such a ‘type system’ which checks type and avoids errors has a property of being type sound.  At the same time, a language can be type ‘unsound’ even if it is judged acceptable by the type checker.
Type systems and correspondingly type checkers rely on the language being formally specified. At the same time, Informal language specification leads to unambiguous implementation of the type system. On the other hand, formal and precise specifications can be evaluated by type checking algorithms unambiguously. Type languages have data categorized into upper-bounds and ranges of values. Languages that don’t restrict the range of variables are called ‘untyped’ languages. Many a times, such languages have a single universal type.
Safe languages are those languages which take care of untrapped errors. They are generally a mixture of runtime and compile time/static checks.
Well typed languages are mostly ‘well behaved’ as in no forbidden execution errors but the fact that a language is statically checked doesn’t mean it can run blindly, without any runtime checks. Checks like array out of bounds need to be done at runtime even if at compile time everything is checked and proper. Importantly, Most ‘untyped’ languages need to be completely safe at runtime by necessity as they don’t necessarily check type safety at compile time.
The expected properties of type systems are they must be safe, typed, evaluated by a type-checking algorithm, transparent and enforceable at either the compile time or runtime. All these properties are aided by the specification of the language being formal. Formalization process consists of describing the syntax, scoping the rules of the language both lexical scope and dynamic scope.
Type equivalence is also measured whether it be structural equivalence or ‘by-name’ equivalence. Type equivalence ventures in languages where ‘subtyping’ is provided. Subtyping allows an object to be used flexibly in many different contexts. The inheritance provision in Java is an example of subtypes. A supertype-subtype relation is of utmost importance in designing applications and making them work. It gives way to effective polymorphism. Then, type inference and type reconstruction also venture in untyped languages giving them leverage to infer and reconstruct type usually based on the value and environment of the type.
In all, typed and untyped languages have been researched and many effective changes have been brought about. Both the kind of languages have their own pros and cons. One must be careful and apply these languages in appropriate contexts.
